{"pages":[{"title":"About this blog","text":"Japanese Ver. Data Science를 좋아하는 학생입니다.특히나, Causal Inference분야에 관심이 많습니다.R, python을 사용하고 있습니다.다양한 사람들과 소통하며 공부하기를 희망하고 있습니다. ・블로그 운영의 목적 스스로의 복습용 메모 주로 머신러닝의 응용처로써의 통계적 인과추론(Causal Inference)에 대해 학습한 내용을 정리합니다. 함께 공부하는 사람에 대한 내용 공유 한국과 일본의 학습자들과 공유하기 위해 모든 블로그 포스트는 한국어 버젼과 일본어 버젼 두가지로 작성하고 있습니다. 부족한 부분이 많습니다. 오타나 잘못된 내용을 발견하셨다면 댓글로 알려주세요.","link":"/About-this-blog/index.html"},{"title":"About this blog","text":"Korean Ver. Data Scienceが大好きな学生です。特に、Causal Inferenceの分野に興味を持っています。R, pythonを使っています。色んな方とコミュニケーションを取りながら学習することを願っています。 ・ブログの目的 自分自身の復習用のメモ 主に機械学習の応用先としての統計的因果推論(Causal Inference)について勉強した内容をまとめます。 他の学習者への内容共有 日本と韓国の学習者と共有するために全てのポストは、日本語バージョンと韓国語バージョンの二通りで作成しています。 まだまだ足りないところが沢山です。 誤字及び間違った内容が見つかりましたら、いつでもコメントください。","link":"/About-this-blog-jap/index.html"}],"posts":[{"title":"【 도대체 베이지안 네트워크가 뭐야? ①】","text":"* 베이지안 네트워크(BN; Bayesian Network) 란? 확률 변수(RV; Random variables)들 사이의 조건부 독립 등의 관계를 보임으로써, RV의 full joint distribution등을 간결하게 표현할 수 있는 그래프 표기법 (Graphical Notation) 이다. 여기서 그래프(Graph) 란, 수학에서 차트(Chart)와 대조되어 정의된 node와 edge의 집합 edge가 방향이 지정되어 있으면 directed, 그렇지 않으면 undirected 그래프의 모든 edge가 directed일 때 directed graph directed edge에서, 시작되는 쪽의 노드를 parent node 라고 하고 반대쪽은 child node라고 한다 복수의 연결된 directed edge의 방향이 같은 경우 이를 directed path라고 하고, directed path의 첫 번째 노드는 경로상의 모든 노드들의 ancestor node이고, 반대로 나머지 노드들은 첫번째 노드의 descendant node이다. directed path의 시작점과 끝점이 일치할 경우 이를 cyclic이라 하고, 그렇지 않은 경우 acyclic라고 한다. 베이지안 네트워크(BN) 의 Syntax Network 는 Node와 이들을 연결시키는 Edge로 구성된다 방향성 비순환 그래프(DAG; Directed Acyclic Graph) 가 되어야 한다 개별 Node들은 RV인 \\(X\\)에 대해 \\(\\bf P(X | Paranets(X))\\)를 의미한다. 개별 Edge들은 부모가 자식에게 주는 직접적인 영향(Direct Influence) 을 의미한다. * 먼저 확률에 대한 간단한 복습부터 베이지안 네트워크 라는 것은 결국 확률변수(RV) 간의 관계 를 표현한 것이다. 확률 이라는 것은 상대적인 빈도 이다. 독립성 (Independence) \\(P(A|B) = P(A)\\) \\(\\Leftrightarrow P(A,B) = P(A)P(B)\\) \\(\\Leftrightarrow P(B|A) = P(B)\\); A와 B가 독립이면, B는 A와 독립이다. 사건B가 발생했다는 정보는 사건A가 발생할 확률에 추가적인 정보를 제공하지 못한다. 이는, 밑에 서술하는 Conditional Independence 와 대립되는 의미로 Marginal Independence 라고 할 수 있다. 조건부 독립 (Conditional Independence) \\(P(A|B,C) = P(A|C)\\) 사건C가 주어졌을 때 두 사건 A와 B가 독립인 경우, 이것은 C라는 조건하에서 조건부 독립 이다. 조건부 확률 (Conditional Probability) \\(P(A= true|B=true)\\) \"Probablity of A given B\" B가 주어졌을 때, A의 확률 결합 확률 (joint Probability) \\(P(A= true, B=true)\\) \"the probability of A=true and B=true\" A=true와 B=true가 동시에 만족할 확률 조건부 확률과 결합 확률의 관계 는 일반적으로, \\(P(X|Y) =\\cfrac{P(X,Y)}{P(Y)}\\) 총 확률 법칙 (Law of Total Probability) \"Summing out\" or \"Marginalization\" \\(P(A) = \\sum_kP(A,B_k) = \\sum_kP(A|B_k)P(B_k)\\) \\(P(A) = \\sum_kP(A,B_k)\\) 는 \\(B_1,B_2,...,B_n\\)이 각각 상호배반적인 집합이고 이들의 합집합이 전체집합이 되므로 성립 (marginalize) \\(\\sum_kP(A,B_k) = \\sum_kP(A|B_k)P(B_k)\\)는 조건부확률과 결합확률의 관계를 이용하면 유도가능 이로 인한 이점은, \\(P(A)\\)를 직접 구하는 것보다, \\(P(A|B_k)\\)와 같은 조건부확률을 구해서 합치는 것이 일반적으로 더 수월하다는 것이다. 혹은 결합확률을 알고 있을 때, 여러가지 확률을 계산 할 수 있다. 예를들어, 결합확률인 \\(P(a,b,c,d)\\)를 알고 있을 때, \\(P(c|b)\\)는 이렇게 표현할 수 있다 \\(P(c|b) = \\sum_a \\sum_d P(a,c,d|b) = \\cfrac{1}{P(b)}\\sum_a \\sum_d {\\bf P(a,b,c,d)}\\) 그러나 joint의 경우에는 parameter의 수가 exponential하게 늘어나게 된다! (Chain Rule의 필요성) 확률의 연쇄법칙 (Chain Rule for probability) 모든 joint distribution에 대해, 결합확률과 조건부확률의 관계에 의해 언제나 이하와 같이 표현할 수 있다. \\(P(a,b,c,...,z) = P(a|b,c,...,z)P(b,c,....,z)\\) 이것을 반복적으로 하면, \\(P(a,b,c,...,z) = P(a|b,c,...,z)P(b|c,...,z)P(c|d,...,z)...P(z)\\)로 표현 가능하다. (Factorization) 곱 분해 법칙 (Rule of product decomposition) 그래프로 표현된 경우, 그래프가 acyclic graph 라면 그래프에 속한 RV의 결합분포(joint distribution)는 family의 모든 조건부 분포 \\(P(Child|Parent)\\)의 곱으로 표현 할 수 있다. \\(P(x_1,x_2,...,x_n) = \\prod _iP(x_i|Parents(x_i))\\) Parents는 직접적으로 연결되어 영향을 받는 변수만을 의미! 예를 들어, \\(X\\rightarrow Y \\rightarrow Z\\) 인 그래프에서 \\(P(X=x, Y=y, Z=z)\\)를 구하는 것을 생각해보자 원래는 가능한 모든 조합의 \\((x, y, z)\\)에 해당하는 확률 테이블을 만들어야 한다 그러나, 이 법칙을 이용하면 \\(P(X=x, Y=y, Z=z) = P(X=x)P(Y=y|X=x)P(Z=z|Y=y)\\)로 간결하게 표현 가능 이처럼 고차원을 저차원으로 만들어 차원의 저주(curse of dimensionality) 에서도 비교적 자유로워 질 수 있다. * 베이지안 네트워크의 Typical Local Structures Rules Rule 1. 사슬 혹은 폭포형 (Chain or Cascading) 변수\\(X\\)와 변수\\(Y\\)의 사이에 하나의 방향성 경로 만 있고 변수\\(Z\\)가 해당 경로를 가로막고 있는 경우, \\(Z\\)가 조건부로 주어졌을때 두 변수 \\(X\\)와 \\(Y\\)는 조건부 독립 이다. \\(X \\perp Y|Z\\) \\(\\Leftrightarrow P(Y|X,Z) = P(Y|Z)\\) Rule 2. 분기 혹은 공통부모형 (Fork or Common parent) 변수 \\(Z\\)가 \\(X\\)와 \\(Y\\)의 공통 원인이고 \\(X\\)와 \\(Y\\)사이에 단 하나의 경로가 있는 경우, \\(Z\\)의 조건이 주어졌을 때 \\(X\\)와 \\(Y\\)는 조건부 독립 이다. \\(X \\perp Y | Z\\) \\(\\Leftrightarrow P(X,Y|Z) = P(X|Z)P(Y|Z)\\) Rule 3. 충돌부 혹은 V-구조 (Collider or V-structure) 변수 \\(Z\\)가 두 변수 \\(X\\)와 \\(Y\\) 사이의 충돌 노드이고 \\(X\\)와 \\(Y\\) 사이에 단 하나의 경로 만 있을 경우, \\(X\\)와 \\(Y\\)는 비조건부 독립(underconditionally independent) 이다. 그러나 \\(Z\\) 또는 \\(Z\\)의 descendant을 조건부로 하였을 때 \\(X\\)와 \\(Y\\)는 종속적일 가능성 이 있다. \\(\\sim (X \\perp Y|Z)\\) \\(\\Leftrightarrow P(X,Y,Z)=P(X)P(Y)P(Z|X,Y)\\) 즉 \\(Z\\)가 not given 일 때는 독립이지만, 반대로 \\(Z\\)가 given으로 주어지면 \\(X\\), \\(Y\\)가 종속적이 될 가능성이 생겨버린다. * Bayes Ball Algorithm 목적 ; \\(X \\perp Y | Z\\) (\\(Z\\)가 given일 때 \\(X\\)와 \\(Y\\)가 독립) 이 성립하는지 여부를 판정하기 위한 알고리즘 \\(X\\)에서 공이 출발한다고 가정했을 때 \\(Y\\)까지 공이 도달하는지 확인하는 방법 여기서 공은 Information을 의미하고 화살표는 공의 움직임을 의미한다. 노드 간이 직접적인 edge로 연결되어 있지 않더라도 공이 굴러가서 도달할 수 있다면 Indirect influence가 존재하기때문에 두 변수는 depedent하다는 것을 의미한다. Rule 1의 경우 (1). \\(Z\\)가 given이 아닐 때, 공은 지나갈 수 있다. (\\(X, Y\\)는 종속) (2). \\(Z\\)가 given 일 때, 공은 지나갈 수 없다. (\\(X \\perp Y|Z\\)) Rule 2의 경우 (1). \\(Z\\)가 given이 아닐 때, 공은 지나갈 수 있다. (\\(X, Y\\)는 종속) (2). \\(Z\\)가 given 일 때, 공은 지나갈 수 없다. (\\(X \\perp Y|Z\\)) Rule 3의 경우 (1). \\(Z\\)가 given이 아닐 때, 공은 지나갈 수 없다. (\\(\\bf X \\perp Y\\)) (2). \\(X_C\\)가 given 일 때, 반대로 path가 생겨서 공이 지나갈 수 있게 된다. (\\(X, Y\\)는 종속 \\(|Z\\)) Bayes Ball Algorithm 연습 문제 1. \\(X_1\\perp X_4|X_2\\) 두가지 경로로 공을 굴릴 수 있다. (1). \\(X_1 \\rightarrow {\\bf X_2}(given) \\rightarrow X_4\\) 의 경로는 \\(X_2\\)가 사슬의 given으로 막혀있으므로 지나갈 수 없다. (2). \\(X_1 \\rightarrow X_3 \\rightarrow X_5 \\rightarrow X_6 \\leftarrow {\\bf X_2}(given) \\rightarrow X_4\\) 의 경로는 \\(X_6\\)가 충돌부의 not given으로 막혀있으므로 지나갈 수 없다. 따라서 어떠한 경로로도 볼은 지나갈수 없으므로 \\(X_2\\)가 given일 때 \\(X_1\\)와 \\(X_4\\)는 독립 이다. 문제 2. \\(X_2\\perp X_5|X_1\\) 두가지 경로로 공을 굴릴 수 있다. (1). \\(X_2 \\rightarrow X_6 \\leftarrow X_5\\) 의 경로는 \\(X_6\\)가 충돌부의 not given으로 막혀있으므로 지나갈 수 없다. (2). \\(X_2 \\leftarrow {\\bf X_1}(given) \\rightarrow X_3 \\rightarrow X_5\\) 의 경로는 \\(X_1\\)가 분기의 given으로 막혀있으므로 지나갈 수 없다. 따라서 어떠한 경로로도 볼은 지나갈수 없으므로 \\(X_1\\)가 given일 때 \\(X_2\\)와 \\(X_5\\)는 독립 이다. 문제 3. \\(X_1\\perp X_6|\\{X_2, X_3\\}\\) 두가지 경로로 공을 굴릴 수 있다. (1). \\(X_1 \\rightarrow {\\bf X_2}(given) \\rightarrow X_6\\) 의 경로는 \\(X_2\\)가 사슬의 given으로 막혀있으므로 지나갈 수 없다. (2). \\(X_1 \\rightarrow {\\bf X_3}(given) \\rightarrow X_5 \\rightarrow X_6\\) 의 경로는 \\(X_3\\)가 사슬의 given으로 막혀있으므로 지나갈 수 없다. 따라서 어떠한 경로로도 볼은 지나갈수 없으므로 \\(\\{X_2, X_3\\}\\)가 given일 때 \\(X_1\\)와 \\(X_6\\)는 독립 이다. 문제 4. \\(X_2\\perp X_3|\\{X_1, X_6\\}\\) 두가지 경로로 공을 굴릴 수 있다. (1). \\(X_2 \\leftarrow {\\bf X_1}(given) \\rightarrow X_3\\) 의 경로는 \\(X_1\\)가 분기의 given으로 막혀있으므로 지나갈 수 없다. (2). \\(X_2 \\rightarrow {\\bf X_6}(given) \\leftarrow X_5 \\leftarrow X_3\\) 의 경로는 \\(X_6\\)가 충돌부의 given으로 뚫려있으므로 지나갈 수 있다. 따라서 두번째 경로로 볼은 지나갈 수 있으므로 \\(\\{X_1, X_6\\}\\)가 given일 때 \\(X_2\\)와 \\(X_3\\)는 독립이 성립하지 않는다. * \\(d\\)-Seperation의 정의 \\(d\\)는 방향성(directly)을 의미한다. Bayesian Ball Algorithm으로 \\(d\\)-Seperation을 확인할 수 있다. 정리하자면, 경로p가 노드 \\(Z\\)에 의해 \\(d\\)-Seperate된다는 명제는 이하와 필요충분조건이다. 경로p는 중간노드 \\(Z\\) 의 사슬 \\(X \\rightarrow Z \\rightarrow Y\\) 또는 분기 \\(X \\leftarrow Z \\rightarrow Y\\) 를 포함한다. 경로p는 중간노드 \\(Z\\) 의 충돌부 \\(X \\rightarrow Z \\leftarrow Y\\) 를 포함하지 않는다. * Reference 해당 포스트는 유튜브 채널「AAILab Kaist」의 문일철 교수님의 강의를 정리 &amp; 추가한 내용임을 밝힙니다. 추가 내용 참조 의학 및 사회과학 연구를 위한 통계적 인과추론 （Judea Pearl, Madelyn Glymour, Nicholas P. Jewell）","link":"/2020/11/14/bayesian%20network/"},{"title":"【Causal Inference 입문편 ①】인과추론의 목적과 RCT에 관하여","text":"* 인과추론(Causal Inference)으로 뭘 할 수 있는데? \"A사 맥주를 공중파 CF에 내보냈을때, 해당 아이스크림의 매상은 얼마나 올랐을까?\" \"전 사원 대상 Python 연수 프로그램을 설치 했을때, 사원 들의 일의 능률은 얼마나 올랐을까?\" 이와 같은 질문들은 비즈니스에서 일상적으로 흔히 나올 수 있는 질문들이다. 하지만 이에 대해 깊은 고찰 없이 단순하게 효과를 정의하고 평가함 으로써, 우리는 수많은 바이어스 를 만들어 내고 있다. 공중파 CF의 효과를 계산하기 위해 단순히 CF 전후의 매상의 차이를 계산해서, CF와 관계없이 시기적으로 날씨가 더워져서 오른 맥주의 매상까지도 CF의 효과로써 평가해버린다. 또한 Python 연수를 신청한 사람들은 그렇지 않은 사원들보다 원래부터 우수한 사람이 많았을 수 있다. 원래부터 일의 능률이 높은 연수자그룹과 비연수자 그룹의 능률을 단순 비교해서 원래의 차이까지도 python 연수의 효과로 평가해버리기 십상이다. 이처럼 인과추론의 목적을 철저하게 비즈니스적 관점에서 보자면 어떠한 시책의 정확한 효과측정 을 위한 이론 &amp; 기술 분야라고 할 수 있다. * 추론(Inference) 의 신뢰성의 3단계 Level 1. 실험(Experimental) 레벨 RCT (Randomized Controlled Trial; 무작위화 비교 실험) 3가지 기본요건 (1). 비교 : Control Group과 Treatment Group 의 비교를 통해 독립변수가 종속변수에 영향을 미쳤는지 확인하는 과정 (2). 조작 : 시간적으로 독립변수가 먼저 발생하고 그 후에 뒤따라 종속변수가 발생함을 입증하기 위해, 임의로 독립변수를 의도적인 시기에 발생하도록하고 이에 뒤따른 종속변수의 변화를 측정하도록 시간적 순서를 조작하는 것 (인과성의 선후관계) (3). 통제 : 허위적 관계가 아닌 것을 입증하기 위해, 독립변수를 제외한 종속변수에 영향을 미칠 수 있는 여러 변수들이 종속변수에 영향을 미치지 못하도록 상황을 의도적으로 통제하는 것 Level 2. 준실험(Quasi Experimental) 레벨 Level 1의 실험설계는 인과관계를 명확히 구명할 수 있지만, 인위적 통제가 어렵거나 윤리적 문제등으로 인해 (특히 비즈니스의 경우 제한된 예산 등에 의해) 실제 활용이 매우 어렵다. 이에 따라 비록 실험 설계에는 미치지 못하지만, 그 대안적인 방법으로 활용되는 방법이다. 대표적인 방법 (1). 시계열 설계(time-series design) : 비교집단을 별도로 설정하기 곤란한 경우에 하나의 집단 을 선택해서, 독립변수 도입의 전후상태를 비교하는 방법이다. 외적요인에 대한 통제가 어렵기 때문에 (각 기간마다 외부의 영향이 다르다), 위험이 있을 수 있다. 이를 개선하기 위해서는 같은 조사를 여러 집단에서 되풀이하여 실시하여 같은 결과를 얻을 수 있는지 확인할 필요가 있다. (2). 비동일 통제집단 설계(nonequivalent control group design) : 비동일 통제집단 설계는 실험설계의 통제집단 전후비교와 유사하지만 비교집단을 무작위로 선정하지 않는다 는 차이가 있다. 비동일 통제집단 설계는 무작위배치 이외의 방법(매칭, 기존집단의 선정 등)으로 Control Group 및 Treatment Group을 선정한다. Level 3. 관찰(Observation) 레벨 독립변수를 조작할 수 없고, 연구대상을 무작위화할 수 없는 경우 이다. 어느 한 시점에서 독립변수와 종속변수 모두를 측정해서 상관관계를 파악하는데에 그친다. 선후관계가 파악되지 않았고, 무작위화를 통해 동일한 집단에서 비교하지 못했으므로 부적절한 해석을 하게 될 위험을 가지고 있다. 확증편향 \\(^{[*1]}\\)(confirmation bias) 이나 사후해석편향 \\(^{[*2]}\\)(hindsight bias)에 영향을 받기 쉽다. 예를 들어, 시책 담당자가 좋은 결과만을 보고 싶다고 하면 집계의 방법을 유리하게 설정해서 유리한 결과가 나오도록 하는 것이 얼마든지 가능하므로 주의가 필요하다. Level 3은 Level 1&amp; Level 2를 한 후에 추가적으로 검토하는 용도. 또한, 집계의 방법을 미리 정해놓는 것을 통해, 자의적으로 변경해서 입맛에 맞는 해석을 하지 않는 것이 중요하다. 【여기서 기억해야 할 것】 Lv1 \\(\\rightarrow\\) Lv2 \\(\\rightarrow\\) Lv3 의 순서로 시책의 효과를 검토해가는 것이 중요하다!! \\(^{[*1]}:\\) 원하는 정보를 선택적으로 모으는 등의 가지고 있는 신념을 확인하려는 경향성. \\(^{[*2]}:\\) 어떤 사건이 발생한 후, 사전에 그런 일이 일어날 것으로 예상했었다는 식으로 문제를 처리하는 것. 실제로는 벌어진 사건에 대해 전혀 대비를 하지 못하고, 그 원인을 냉정하게 규명해야 함에도 불구하고 \"충분히 예측했던 일\"이라며 자기 확신에 빠지는 것. * Potential Outcome Framework 처치(Treatment) 혹은 개입(Intervention)이 이뤄졌는지 여부 \\(\\begin{equation}Z_i= \\left \\{\\begin{array}{l}1 (Treated) \\\\0 (Untreated)\\end{array}\\right.\\end{equation}\\) 종속변수(DV; Dependent Variable) 혹은 목적변수(Criterion Variable) ; 개입을 받은 경우와 받지 않은 경우 두가지로 나타낼 수 있다. (실제로는 어느 한쪽만 관찰가능하지만) \\(\\begin{equation}Y_i= \\left \\{\\begin{array}{l}Y_i^{(1)} (Z_i = 1) \\\\Y_i^{(0)} (Z_i = 0)\\end{array}\\right.\\end{equation}\\) \\(\\Rightarrow Y_i = Y_i^{(0)}(1- Z_i) + Y_i^{(1)}Z_i\\) 이와 같이, 샘플 \\(i\\) 에 대하여 개입을 받은 경우의 결과 \\(Y^{(1)}\\) 와 받지 않은 경우의 결과 \\(Y^{(0)}\\) 간의 차이가 개입의 진정한 처치효과(TE; Treatment Effect) 라고 가정하는 것을 Potential Outcome Framework 라고 한다. \\(\\bf \\tau_{TE} = Y^{(1)}-Y^{(0)}\\) 모든 샘플 \\(i\\) 에 대해 각각의 처치효과를 구하는 것은 까다롭기 떄문에, 그룹간의 비교로써 평균처치효과(ATE; Average Treatment Effect) 를 다루는 경우도 많다. \\(\\bf \\tau_{ATE}= E[Y^{(1)}]-E[Y^{(0)}]\\) * 인과추론의 기초, RCT RCT의 특징 비즈니스의 관점에서는 AB테스트 라고 할 수 있다. RCT (Randomized Controlled Trial; 무작위화 비교 실험)를 통해 Control Group과 Treatment Group을 무작위하게 나눔으로써 두 그룹간의 동질성 을 기대할 수 있다. 즉 RCT에서는 이론상, \\(ATU = ATT = ATE\\)을 기대할 수 있다. \\(ATU\\) (Average Treatment Effect on the Untreated) \\(= E[Y^{(1)}|Z=0] - E[Y^{(0)}|Z=0]\\) \\(ATT\\) (Average Treatment Effect on the Treated) \\(= E[Y^{(1)}|Z=1] - E[Y^{(0)}|Z=1]\\) \\(\\bf ATE\\) (Average Treatment Effect) \\(\\bf = E[Y^{(1)}] - E[Y^{(0)}]\\) \\(^{[*]}\\) 위의 표에서 Control Group의 \\(Y_i^{(1)}\\)과 Treatment Group의 \\(Y_i^{(0)}\\)은 실제로 관찰 불가능한 반사실적 Potential Outcome 이다. RCT의 의의 선택바이어스(Selection Bias) 의 제거 조작변수 이외의 다른 변수들을 통제하지 못한 채 Control Group과 Treatment Group 선택하게 되면, 그룹간의 동질성을 확보하지 못하여 교란변수(confounding factor) 에 의해 효과가 왜곡 될 수있다. 이러한 것을 선택 바이어스 라고 한다. RCT는 완전 무작위로 처치그룹을 선택하기 때문에 선택 바이어스 에서 자유로워질 수 있다. RCT의 어려운 점 (1). 비용이 많이 든다. (2). noncompliance 문제 RCT에서 무작위로 그룹을 배분해도 거기에 따르지 않는 사람이 생겨서 나타나는 문제 (3). (특히 AB테스트에서) 다른 RCT를 같은 대상자에 겹쳐서 실행하게 될 경우, 그에 따른 바이어스가 생길 수 있다. 통계적으로 처리하기가 상당히 복잡해진다. * Reference 해당 포스트는 유튜브 채널「データの科学のメソドロジー」의 山田典一님의 강의를 정리 &amp; 추가한 내용임을 밝힙니다. 추가 내용 참조 効果検証入門〜正しい比較のための因果推論/計量経済学の基礎 （安井翔太） RCTをめぐる3つの問題とその解法（山口一男） http://blog.daum.net/sangrimza/15612241 https://healthpolicyhealthecon.com/2015/02/23/experiment-and-quasi-experiment-1/","link":"/2020/11/30/CI1/"}],"tags":[{"name":"causal","slug":"causal","link":"/tags/causal/"},{"name":"KMOOC","slug":"KMOOC","link":"/tags/KMOOC/"}],"categories":[{"name":"KOR","slug":"KOR","link":"/categories/KOR/"},{"name":"통계적인과추론","slug":"KOR/통계적인과추론","link":"/categories/KOR/%ED%86%B5%EA%B3%84%EC%A0%81%EC%9D%B8%EA%B3%BC%EC%B6%94%EB%A1%A0/"},{"name":"ML","slug":"KOR/통계적인과추론/ML","link":"/categories/KOR/%ED%86%B5%EA%B3%84%EC%A0%81%EC%9D%B8%EA%B3%BC%EC%B6%94%EB%A1%A0/ML/"}]}